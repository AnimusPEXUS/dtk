module dtk.types.Signal;

import std.uuid;
import std.algorithm;

class Signal<T1...> {

    alias ListenerType = bool delegate(T1);

    private
    {
        UUID[] busy_ids;
        ListenerWrapper[] listeners;
    }

    UUID generateNewUUID()
    {
        for (;;)
        {
            auto x = randomUUID();
            if (x !in busy_ids)
                return x;
        }
    }

    ListenerWrapperGCDetector connect(ListenerType listener)
    {
        auto uuid = generateNewUUID();
        listeners ~= listener;
    }

    void disconnect(ListenerType listener)
    {
        auto res = std.algorithms.find(listeners, listener);
        if (res.empty)
        {
            return;
        }
        foreach (ListenerWrapper v; res)
        {
            v.deleted=true;
        }
        listeners = listeners.remove(res[0 .. 1]);
    }

    void disconnect(UUID listener_uuid)
    {
        ListenerWrapper[] listeners_to_delete:
        foreach_reverse (size_t k, ListenerWrapper v; listeners)
        {
            if (v.id == listener_uuid)
            {
                listeners_to_delete ~= v;
            }
        }

        foreach (ListenerWrapper v; listeners_to_delete)
        {
            disconnect(v);
        }
    }

}

class ListenerWrapperRefCounted<T1...>
{
    alias ListenerType = bool delegate(T1);

    private
    {
        UUID id;
        bool deleted=false;
        ListenerType callback;
    }

    void emit(T1){
        if (deleted)
        {
            return;
        }
        callback(T1);
    }

}

class ListenerWrapperGCDetector<T1...>
{
    private
    {
        UUID id;
        Signal<T1> signal;
    }

    this(UUID id, Signal signal)
    {
        this.id=id;
        this.signal=signal;
    }

    ~this()
    {
        signal.disconnect(id);
    }
}
